<!DOCTYPE html> <html lang="en"> <head> <title>PicketLink</title> <meta charset="utf-8"/> <meta content="width=device-width, initial-scale=1.0" name="viewport"/> <link href="http://picketlink.org/css/bootstrap-community.min.css" media="screen" rel="stylesheet"> <script src="http://static.jboss.org/theme/js/libs/html5/pre3.6/html5.min.js"></script> </link> <link href="http://design.jboss.org/picketlink/logo/images/favicon.ico" rel="shortcut icon"/> <style type="text/css">
      /*<![CDATA[*/
        @media (min-width: 980px) {
          .banner { background-image: url(http://www.jboss.org/dms/picketlink/images/picketlink-banner-1180px.png); background-repeat: no-repeat; height: 110px;  }
        }
        @media (max-width: 979px) {
          .banner { background-image: url(http://design.jboss.org/picketlink/logo/images/picketlink_logo_600x.png); background-repeat:no-repeat; height: 60px; }
        }
        @media (max-width: 650px) {
          .banner { width: 500px; margin: 0px auto; }
        }
      /*]]>*/
    </style> <script src="http://static.jboss.org/theme/js/libs/jquery/jquery-1.9.1.min.js"></script> <link href="http://picketlink.org/stylesheets/blog.css" rel="stylesheet" type="text/css"/> <link href="http://picketlink.org/stylesheets/asciidoctor-coderay.css" media="screen" rel="stylesheet" type="text/css"/> <link href="/stylesheets/sh/shCore.css" rel="stylesheet"/> <link href="/stylesheets/sh/shThemeDefault.css" rel="stylesheet"/> <link href="/stylesheets/sh/SyntaxHighlighter.css" rel="stylesheet"/> <style type="text/css">
      /*<![CDATA[*/
        td.download-size {
          text-align: right;
          padding-right: 10px;
        } 
        
        .white-stripes tr:nth-child(even) {
          background-color: white;
        }
        .white-stripes tr:nth-child(odd) {
          background-color: none;
        }
      /*]]>*/
    </style> </head> <script src="/javascripts/sh/shCore.js"></script> <script src="/javascripts/sh/shBrushJava.js"></script> <script src="/javascripts/sh/shBrushXml.js"></script> <script src="/javascripts/sh/shBrushBash.js"></script> <script type="text/javascript">
    //<![CDATA[
          SyntaxHighlighter.defaults['gutter'] = false;
          SyntaxHighlighter.defaults['toolbar'] = false;
          // register a listener for when the highlighter is done with replacing elements
          SyntaxHighlighter.all();
    //]]>
  </script> <body> <ul class="visuallyhidden" id="top"> <li> <a accesskey="n" href="#nav" title="Skip to navigation">Skip to navigation</a> </li> <li> <a accesskey="c" href="#page" title="Skip to content">Skip to content</a> </li> </ul> <div class="container" id="content"> <div class="dropup"> <a class="tabnav-closed" href="https://www.redhat.com" id="tab">Red Hat</a> </div> <div class="banner"> <a href="http://picketlink.org"></a> <div class="taglinedark visible-desktop"></div> </div> <div class="navbar navbar-inverse" id="navbar-fix"> <div class="navbar-inner"> <div class="container"> <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </a> <div class="nav-collapse collapse"> <ul class="nav" id="nav"> <li class=""><a href="http://picketlink.org/">Home</a></li> <li class=""><a href="http://picketlink.org/about/">About</a></li> <li class=""><a href="http://picketlink.org/news">News</a></li> <li class=""><a href="http://picketlink.org/gettingstarted/">Getting Started</a></li> <li class=""><a href="http://docs.jboss.org/picketlink/2/latest/reference/html/">Documentation</a></li> <li class=""><a href="http://picketlink.org/gethelp/">Get Help</a></li> <li class=""><a href="https://github.com/picketlink/picketlink">Source Code</a></li> <li class=""><a href="http://picketlink.org/testimonials/testimonial/">Testimonials</a></li> <li class=""><a href="http://picketlink.org/joinus/">Join Us</a></li> <li class="dropdown"> <a class="dropdown-toggle" data-toggle="dropdown" href="#">Follow Us <b class="caret"></b></a> <ul class="dropdown-menu projectsocialmedia"> <li><a href="http://twitter.com/picketlink"><img src="http://static.jboss.org/theme/images/common/socialmedia_icon40_twitter.png"/></a></li> <li><a href="https://plus.google.com/communities/101791570551871936976"><img src="http://static.jboss.org/theme/images/common/socialmedia_icon40_googleplus.png"/></a></li> <li><a href="http://facebook.com/picketlink"><img src="http://static.jboss.org/theme/images/common/socialmedia_icon40_facebook.png"/></a></li> </ul> </li> </ul> </div> </div> </div> </div> <span id="page"></span> <div class="row-fluid"> <div class="row-fluid"> <div class="span12 well post-bg"> <div class="row-fluid"> <div class="span12"> <h2>Custom Identity Model</h2> <p> This guide will show you how to use the PicketLink Identity Management API to design and implement your own identity model accordingly with your requirements. </p> <p> PicketLink IDM provides a very extensible <a href="http://docs.jboss.org/picketlink/2/latest/reference/html/sect-Identity_Model.html">Identity Model</a> from which you can build your own representation of security-related entities such as users, roles, groups, devices, applications, partitions, relationships between them and so forth. </p> <p> It also provides a default implementation to support some very common security concepts, the <a href="http://docs.jboss.org/picketlink/2/latest/reference/html/chap-Identity_Management_-_Basic_Identity_Model.html">Basic Model.</a> The Basic Model can be used for most applications, covering some basic security requirements and representations for users, roles, groups, grant roles to users or turn them as members of different groups. </p> <p> However, some applications may have a more complex set of requirements and require different types in order to better represent their own security-related concepts. This guide will show you how to satisfy those specific requirements and how to implement them using the PicketLink IDM API. Once you read this guide you should be able to: </p> <ul> <li> Understand what is an Identity Model </li> <li> Understand the limitations of the Basic Model </li> <li> Understand when you need to provide your own Identity Model </li> <li> Extend PicketLink IDM and provide your own Identity Model </li> <li> How to Use PicketLink JPA Mapping Annotations to store your own Identity Model </li> </ul> <p> <b>All code for this guide is available from the <a href="https://github.com/jboss-developer/jboss-picketlink-quickstarts/tree/master/picketlink-idm-custom-identity-model">Custom Identity Model Quickstart.</a> Please, check it out for a full working example.</b> </p> <h2>Choosing and Designing an Identity Model to Your Application</h2> <p> Before enabling security into your application you should ask yourself about what it needs in order to represent all entities involved with your security requirements. </p> <p> Let's say that some of these requirements are password-based authentication and RBAC (Role-based Access Control), pretty common in most applications. You would probably need something to represent users, roles and password-based credentials. And this is exactly what an Identity Model is, a representation of entities required by your application in order to support its security requirements. </p> <p> In this guide we're going to consider the following security requirements to design a identity model: </p> <ul> <li> Support multiple security domains or realms, where each realm defines a set of security policies such as a key pair, HTTP/SSL enforcement, maximum number of failed login attempts. </li> <li> A security domain may have one or multiple applications. They inherit all policies defined by the security domain they belong. </li> <li> A security domain may have one or multiple users. Where each user is allowed to access a set of applications from a specific security domain. </li> <li> A security domain may have one or more roles. They are visible by all applications for a specific realm, also called global roles. </li> <li> A security domain may have one or more groups. They are visible by all applications for a specific realm, also called global groups. </li> <li> An application may have one or more roles. They are not shared by other applications. </li> <li> An application may have one or more groups. They are not shared by other applications. </li> <li> Users and groups are granted with roles. When granted to a group, all its members inherit the roles granted to the group. </li> <li> Applications are accessible only from authorized users. If a group is authorized, all its members are allowed to access an application. </li> <li> Users must be authenticated using an username/password credential </li> </ul> <p> Considering these requirements, we can define an identity model as follows: </p> <img src="http://picketlink.org/images/custom_idm_model_640_480.png"/> <h2>Partition, IdentityType, Account and Relationship Types</h2> <p> PicketLink defines four basic types to represent security-related entities: </p> <ul> <li> <code>Partition</code> </li> <li> <code>IdentityType</code> </li> <li> <code>Account</code> </li> <li> <code>Relationship</code> </li> </ul> <div class="well"> Please, take a look at the <a href="http://docs.jboss.org/picketlink/2/latest/reference/html-single/#sect-Identity_Model">documentation</a> for more details about each one. </div> <h2> Creating Partition Types </h2> <p> Considering the requirements, the following types represent a <code>Partition</code>: </p> <ul> <li> Realm </li> <li> Application </li> </ul> <p> In PicketLink, <code>IdentityType</code> instances are associated with a single partition. A partition defines a scope for identity types, providing a logical separation between them. Types stored in a partition are only accessible from it. For instance, users belong to a realm and are accessible by all its applications. But users from a realm are not accessible to other realms. The same applies for roles, where roles defined by a realm are accessible to all applications, representing "global" roles. </p> <p> Applications can also have their own roles and groups. Roles and groups can not be shared between applications. For this reason, we also need to consider them as partitions as well. </p> <div class="well"> Please, take a look at <a href="http://docs.jboss.org/picketlink/2/latest/reference/html/sect-Partition_Management.html">Partition Management</a> for more information. </div> <p> Let's start by defining the <code>Realm</code> partition. </p> <pre class="brush: java;">&#x000A;@IdentityPartition(supportedTypes = {Application.class, User.class, Role.class, Group.class})&#x000A;public class Realm extends AbstractPartition {&#x000A;&#x000A;  @AttributeProperty&#x000A;  private boolean enforceSSL;&#x000A;&#x000A;  @AttributeProperty&#x000A;  private int numberFailedLoginAttempts;&#x000A;&#x000A;  @AttributeProperty&#x000A;  private byte[] publickKey;&#x000A;&#x000A;  @AttributeProperty&#x000A;  private byte[] privateKey;&#x000A;&#x000A;  // PicketLink requires a default constructor to create and populate instances using reflection&#x000A;  private Realm() {&#x000A;    this(null);&#x000A;  }&#x000A;&#x000A;  public Realm(String name) {&#x000A;    super(name);&#x000A;  }&#x000A;&#x000A;}</pre> <p> The <code>AbstractPartition</code> provides a default implementation for the <code>Partition</code> interface, from which all partition types should implement directly or indirectly. Basically, what this interface defines is a getter to obtain the partition name. All partitions must have a unique name. </p> <p> When creating a partition type, you must also specify which types are supported and can be stored on it. The <code>@IdentityPartition</code> annotation tells PicketLink which types are supported by a partition. In this case, we're saying that only <code>Application</code>, <code>User</code>, <code>Role</code> and <code>Group</code> types can be stores in a <code>Realm</code>. If you try to add some other type, PicketLink will not allow. </p> <p> Partition properties are annotated with <code>@AttributeProperty</code>. This annotation tells to PicketLink that a property must be stored and that it represents some state for a specific type. For <code>Realm</code>, we're storing a key pair and the maximum number of failed login attempts. </p> <p> Now, is just a matter of use the <code>PartitionManager</code> to manage instances of <code>Realm</code> as follows: </p> <pre class="brush: java;">&#x000A;Realm acme = new Realm("Acme");&#x000A;&#x000A;acme.setEnforceSSL(true);&#x000A;&#x000A;// let's generate a keypair for the realm&#x000A;KeyPair keyPair = KeyPairGenerator.getInstance("RSA").generateKeyPair();&#x000A;&#x000A;acme.setPrivateKey(keyPair.getPrivate().getEncoded());&#x000A;acme.setPublickKey(keyPair.getPublic().getEncoded());&#x000A;&#x000A;acme.setNumberFailedLoginAttempts(3);&#x000A;&#x000A;// stores the realm&#x000A;this.partitionManager.add(acme);&#x000A;&#x000A;assertNotNull("Realm identifier not generated.", acme.getId());&#x000A;&#x000A;// retrieves the realm and check state&#x000A;Realm storedRealm = this.partitionManager.getPartition(Realm.class, acme.getName());&#x000A;&#x000A;assertNotNull("Realm not stored.", storedRealm);&#x000A;assertEquals(acme.isEnforceSSL(), storedRealm.isEnforceSSL());&#x000A;assertEquals(acme.getNumberFailedLoginAttempts(), storedRealm.getNumberFailedLoginAttempts());&#x000A;assertEquals(acme.getPrivateKey(), storedRealm.getPrivateKey());&#x000A;assertEquals(acme.getPublickKey(), storedRealm.getPublickKey());</pre> <p> The code above creates a new <code>Realm</code>, populates it with some data, stores it and retrieves it from IDM. </p> <div class="well"> If you're not familiar with PicketLink Identity Management API, please take a look at <a href="../idm_overview">Identity Management Overview</a> guide. </div> <p> The same steps can be followed to create the <code>Application</code> partition, with a little difference. We now implement the <code>Partition</code> interface directly. </p> <pre class="brush: java;">&#x000A;@IdentityPartition(supportedTypes = {Role.class, Group.class})&#x000A;public class Application extends AbstractIdentityType implements Partition {&#x000A;&#x000A;  @AttributeProperty&#x000A;  @Unique&#x000A;  private String name;&#x000A;&#x000A;  public String getName() {&#x000A;    return this.name;&#x000A;  }&#x000A;&#x000A;  public void setName(String name) {&#x000A;    this.name = name;&#x000A;  }&#x000A;&#x000A;}</pre> <p> You may notice that <code>Application</code> is extending <code>AbstractIdentityType</code>. The reason for that is that an application can also be used in relationships in order to authorize access from users. And for that it must be also an <code>IdentityType</code>. We'll cover identity types in the next sections. </p> <pre class="brush: java;">&#x000A;// get the realm where the application should be stored&#x000A;Realm acme = this.partitionManager.getPartition(Realm.class, REALM_ACME_NAME);&#x000A;&#x000A;assertNotNull(acme);&#x000A;&#x000A;// we need an identity manager instance for acme realm. so we can store the application&#x000A;IdentityManager identityManager = this.partitionManager.createIdentityManager(acme);&#x000A;Application salesApplication = new Application("Sales Application");&#x000A;&#x000A;// stores the application in the acme partition&#x000A;identityManager.add(salesApplication);&#x000A;&#x000A;IdentityQuery&lt;Application&gt; query = identityManager.createIdentityQuery(Application.class);&#x000A;&#x000A;// let's check if the application is stored by querying by the identifier&#x000A;query.setParameter(Application.ID, salesApplication.getId());&#x000A;&#x000A;List&lt;Application&gt; applications = query.getResultList();&#x000A;&#x000A;assertEquals(1, applications.size());&#x000A;&#x000A;Application storedApplication = applications.get(0);&#x000A;&#x000A;assertEquals(salesApplication.getName(), storedApplication.getName());&#x000A;&#x000A;Application salesApplicationPartition = new Application(salesApplication.getName());&#x000A;&#x000A;// now, we also need to create a partition for this application&#x000A;this.partitionManager.add(salesApplicationPartition);&#x000A;&#x000A;// applications have two distinct representations: identity type and partition. They mean different things.&#x000A;assertFalse(storedApplication.getId().equals(salesApplicationPartition.getId()));</pre> <p> The code above is an example about how applications must be managed. First, we store the <code>Application</code> as an <code>IdentityType</code> using the <code>IdentityManager</code>. This makes the application accessible only from a specific partition, in this case <i>Acme</i>. Right after, we create a new partition to represent the application and to store its own roles and groups. </p> <h2> Creating an IdentityType </h2> <p> Considering the requirements, the following types represent an <code>IdentityType</code>: </p> <ul> <li> Role </li> <li> Group </li> <li> Application </li> </ul> <p> In PicketLink, an <code>IdentityType</code> is used to represent any security-related entity such as roles, groups, devices, applications, organization units and so forth. In a nutshell, identity types must implement the <code>IdentityType</code> interface. To make life easier, PicketLink also provides <code>AbstractIdentityType</code>, which is a base class with a default implementation. </p> <p> <b>Identity types are always associated with a partition and can not be accessed from other partitions</b>. They can also participate in relationships to associate an user or group with a role or add an user as a member of a group. </p> <div class="well"> Please, take a look at <a href="http://docs.jboss.org/picketlink/2/latest/reference/html/sect-Creating_a_Custom_Identity_Model.html">Custom Identity Model</a> for more information. </div> <p> We have already covered the creation of the <code>Application</code>, let's take a look now how to create the <code>Role</code> and <code>Group</code> types: </p> <pre class="title: 'Role Identity Type'; brush: java;">&#x000A;@IdentityStereotype(ROLE)&#x000A;public class Role extends AbstractIdentityType {&#x000A;&#x000A;    /**&#x000A;     * A query parameter used to query roles by name.&#x000A;     */&#x000A;    public static final QueryParameter NAME = QUERY_ATTRIBUTE.byName("name");&#x000A;&#x000A;    @StereotypeProperty(IDENTITY_ROLE_NAME)&#x000A;    @AttributeProperty&#x000A;    @Unique&#x000A;    private String name;&#x000A;&#x000A;    // PicketLink requires a default constructor to create and populate instances using reflection&#x000A;    private Role() {&#x000A;        this(null);&#x000A;    }&#x000A;&#x000A;    public Role(String name) {&#x000A;        this.name = name;&#x000A;    }&#x000A;&#x000A;    // getters and setters&#x000A;&#x000A;}</pre> <pre class="title: 'Group Identity Type'; brush: java;">&#x000A;@IdentityStereotype(GROUP)&#x000A;public class Group extends AbstractIdentityType {&#x000A;&#x000A;    /**&#x000A;     * A query parameter used to query groups by name.&#x000A;     */&#x000A;    public static final QueryParameter NAME = QUERY_ATTRIBUTE.byName("name");&#x000A;&#x000A;    /**&#x000A;     * A query parameter used to query groups by parent.&#x000A;     */&#x000A;    public static final QueryParameter PARENT = QUERY_ATTRIBUTE.byName("parent");&#x000A;&#x000A;    @StereotypeProperty(IDENTITY_GROUP_NAME)&#x000A;    @AttributeProperty&#x000A;    @Unique&#x000A;    private String name;&#x000A;&#x000A;    /**&#x000A;     * The parent group.&#x000A;     */&#x000A;    @AttributeProperty&#x000A;    private Group parent;&#x000A;&#x000A;    // PicketLink requires a default constructor to create and populate instances using reflection&#x000A;    private Group() {&#x000A;        this(null);&#x000A;    }&#x000A;&#x000A;    public Group(String name) {&#x000A;        this.name = name;&#x000A;    }&#x000A;&#x000A;    // getters and setters&#x000A;&#x000A;}</pre> <p> As mentioned before, identity types must implement <code>IdentityType</code>. Both <code>Role</code> and <code>Group</code> are extending <code>AbstractIdentityType</code>, which is a base class for custom identity types. You may also notice the usage of <code>@AttributeProperty</code>. This annotation tells to PicketLink that a property must be stored and that it represents some state for a specific type. </p> <p> Some identity types are very common between different use cases and requirements, like roles, groups and users. In PicketLink, those common concepts are represented as <a href="http://docs.jboss.org/picketlink/2/latest/reference/html/sect-Stereotypes.html">Stereotypes.</a> Both <code>Role</code> and <code>Group</code> types are annotated with the <code>IdentityStereotype</code>. This annotation tells to PicketLink which stereotype is related with a specific type. This is a very important configuration if you want to integrate your custom types with some built-in features provided by PicketLink, like authorization. </p> <p> Some identity types represents a hierarchy. For instance, groups usually have a parent-child relationship between them. PicketLink allows you to represent hierarchies by just having a property with the same type where it is declared. </p> <pre class="brush: java;">&#x000A;@IdentityStereotype(GROUP)&#x000A;public class Group extends AbstractIdentityType {&#x000A;&#x000A;    /**&#x000A;     * The parent group.&#x000A;     */&#x000A;    @AttributeProperty&#x000A;    private Group parent;&#x000A;&#x000A;}</pre> <p> PicketLink also provides a simple Query API which you can use to retrieve instances based on query parameters. Usually, a query parameter is just a reference to a specific property of your type.: </p> <pre class="brush: java;">&#x000A;@IdentityStereotype(GROUP)&#x000A;public class Group extends AbstractIdentityType {&#x000A;&#x000A;    /**&#x000A;     * A query parameter used to query groups by name.&#x000A;     */&#x000A;    public static final QueryParameter NAME = QUERY_ATTRIBUTE.byName("name");&#x000A;&#x000A;    /**&#x000A;     * A query parameter used to query groups by parent.&#x000A;     */&#x000A;    public static final QueryParameter PARENT = QUERY_ATTRIBUTE.byName("parent");&#x000A;&#x000A;}</pre> <p> This is the only thing you need to start querying instances based on any property annotated with <code>@AttributeProperty</code>. </p> <pre class="brush: java;">&#x000A;// get the realm where global groups are stored&#x000A;Application applicationPartition = this.partitionManager.getPartition(Application.class, APPLICATION_NAME);&#x000A;&#x000A;// we need an identity manager instance for applicationPartition realm. so we can store the group&#x000A;IdentityManager identityManager = this.partitionManager.createIdentityManager(applicationPartition);&#x000A;Group salesUnit = new Group("Sales Unit");&#x000A;&#x000A;// stores the sales unit&#x000A;identityManager.add(salesUnit);&#x000A;&#x000A;Group salesManagers = new Group("Sales Managers");&#x000A;&#x000A;// we set the managers group as a child of sales unit&#x000A;salesManagers.setParent(salesUnit);&#x000A;&#x000A;// stores the managers group&#x000A;identityManager.add(salesManagers);&#x000A;&#x000A;IdentityQuery&lt;Group&gt; query = identityManager.createIdentityQuery(Group.class);&#x000A;&#x000A;// query all childs of sales unit&#x000A;query.setParameter(Group.PARENT, salesUnit);&#x000A;&#x000A;List&lt;Group&gt; salesUnitChilds = query.getResultList();&#x000A;&#x000A;assertEquals(1, salesUnitChilds.size());</pre> <p> And here is an example about how to manage roles for both <code>Realm</code> and <code>Application</code>: </p> <pre class="brush: java;">&#x000A;// get the realm where global roles are stored&#x000A;Realm acme = this.partitionManager.getPartition(Realm.class, REALM_ACME_NAME);&#x000A;&#x000A;assertNotNull(acme);&#x000A;&#x000A;// we need an identity manager instance for acme realm. so we can store the role&#x000A;IdentityManager acmeIdentityManager = this.partitionManager.createIdentityManager(acme);&#x000A;Role globalRole = new Role("Global Role");&#x000A;&#x000A;// stores the global role.&#x000A;acmeIdentityManager.add(globalRole);&#x000A;&#x000A;IdentityQuery&lt;Role&gt; query = acmeIdentityManager.createIdentityQuery(Role.class);&#x000A;&#x000A;// let's check if the role is stored by querying using a name&#x000A;query.setParameter(Role.NAME, globalRole.getName());&#x000A;&#x000A;List&lt;Role&gt; roles = query.getResultList();&#x000A;&#x000A;assertEquals(1, roles.size());&#x000A;&#x000A;Role storedGlobalRole = roles.get(0);&#x000A;&#x000A;assertEquals(globalRole.getName(), storedGlobalRole.getName());&#x000A;&#x000A;Application applicationPartition = this.partitionManager.getPartition(Application.class, APPLICATION_NAME);&#x000A;&#x000A;IdentityManager applicationIdentityManager = this.partitionManager.createIdentityManager(applicationPartition);&#x000A;Role applicationRole = new Role("Application Role");&#x000A;&#x000A;// stores a application specific role&#x000A;applicationIdentityManager.add(applicationRole);&#x000A;&#x000A;query = applicationIdentityManager.createIdentityQuery(Role.class);&#x000A;&#x000A;// let's check if the role is stored by querying using a name&#x000A;query.setParameter(Role.NAME, applicationRole.getName());&#x000A;&#x000A;roles = query.getResultList();&#x000A;&#x000A;assertEquals(1, roles.size());&#x000A;&#x000A;Role storedApplicationRole = roles.get(0);&#x000A;&#x000A;assertEquals(applicationRole.getName(), storedApplicationRole.getName());&#x000A;&#x000A;// let's check if is possible to get the application role from the acme partition&#x000A;query = acmeIdentityManager.createIdentityQuery(Role.class);&#x000A;&#x000A;query.setParameter(Role.NAME, applicationRole.getName());&#x000A;&#x000A;// partitions don't share identity types&#x000A;assertTrue(query.getResultList().isEmpty());</pre> <h2> Creating an Account Type </h2> <p> In PicketLink, an <code>Account</code> is a special type of <code>IdentityType</code> that is capable of authenticating. Since the authentication process may not depend on one particular type of attribute (not all authentication is performed with a username and password) there are no hard-coded property accessors defined by this interface. It is up to each application to define the <code>Account</code> implementations required according to the application's requirements. </p> <p> Create an <code>Account</code> require the same steps as in <code>IdentityType</code>. The main difference is that you must also implement the <code>Account</code> interface. </p> <pre class="brush: java;">&#x000A;@IdentityStereotype(USER)&#x000A;public class User extends AbstractIdentityType implements Account {&#x000A;&#x000A;    @StereotypeProperty(IDENTITY_USER_NAME)&#x000A;    @AttributeProperty&#x000A;    @Unique&#x000A;    private String userName;&#x000A;&#x000A;   // getters and setters&#x000A;&#x000A;}</pre> <p> Just like <code>Role</code> and <code>Group</code> you should also define a stereotype to your user types. PicketLink provides a number of features based on the concept of "users", using his name to authenticate, authorize and recognize your own user representation. </p> <pre class="brush: java;">&#x000A;// get the realm where the user should be stored&#x000A;Realm acme = this.partitionManager.getPartition(Realm.class, REALM_ACME_NAME);&#x000A;&#x000A;assertNotNull(acme);&#x000A;&#x000A;// we need an identity manager instance for acme realm. so we can store the user&#x000A;IdentityManager identityManager = this.partitionManager.createIdentityManager(acme);&#x000A;User user = new User("mary");&#x000A;&#x000A;// stores the user in the acme partition&#x000A;identityManager.add(user);&#x000A;&#x000A;IdentityQuery&lt;User&gt; query = identityManager.createIdentityQuery(User.class);&#x000A;&#x000A;// let's check if the user is stored by querying by name&#x000A;query.setParameter(User.USER_NAME, user.getUserName());&#x000A;&#x000A;List&lt;User&gt; users = query.getResultList();&#x000A;&#x000A;assertEquals(1, users.size());&#x000A;&#x000A;User storedUser = users.get(0);&#x000A;&#x000A;assertEquals(user.getUserName(), storedUser.getUserName());</pre> </div> <p> An <code>Account</code> can use any of the built-in credentials provided by PicketLink such as username/password and One-Time Passwords. Considering our requirements, users should be capable to authenticate using an username/password credential. <pre class="brush: java;">&#x000A;// get the realm where the user should be stored&#x000A;Realm acme = this.partitionManager.getPartition(Realm.class, REALM_ACME_NAME);&#x000A;&#x000A;// we need an identity manager instance for acme realm. so we can store the user&#x000A;IdentityManager identityManager = this.partitionManager.createIdentityManager(acme);&#x000A;User user = new User("mary");&#x000A;&#x000A;// stores the user in the acme partition&#x000A;identityManager.add(user);&#x000A;&#x000A;Password password = new Password("secret");&#x000A;&#x000A;identityManager.updateCredential(user, password);&#x000A;&#x000A;UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(user.getUserName(), password);&#x000A;&#x000A;identityManager.validateCredentials(credentials);&#x000A;&#x000A;assertEquals(VALID, credentials.getStatus());</pre> </p> <h2> Creating a Relationship </h2> <p> Considering the requirements, the following types represent a <code>Relationship</code>: </p> <ul> <li> Grant </li> <li> GroupMembership </li> <li> ApplicationAccess </li> </ul> <p> In PicketLink, relationships are represented by the <code>Relationship</code> interface. Like <code>Partition</code> and <code>IdentityType</code>, relationships must implement a specific interface as well. </p> <p> The same thing regarding stereotypes. PicketLink also provides a set of common relationships which can be defined to your custom relationships such as grant roles to users and groups or tell an user is member of a group. </p> <pre class="title: 'Grant Relationship Type. Used to assign roles for both User and Group types.';brush: java;">&#x000A;@RelationshipStereotype(GRANT)&#x000A;public class Grant extends AbstractAttributedType implements Relationship {&#x000A;&#x000A;  public static final RelationshipQueryParameter ASSIGNEE = RELATIONSHIP_QUERY_ATTRIBUTE.byName("assignee");&#x000A;  public static final RelationshipQueryParameter ROLE = RELATIONSHIP_QUERY_ATTRIBUTE.byName("role");&#x000A;&#x000A;  @InheritsPrivileges("role")&#x000A;  @StereotypeProperty(RELATIONSHIP_GRANT_ASSIGNEE)&#x000A;  private IdentityType assignee;&#x000A;&#x000A;&#x000A;  @StereotypeProperty(RELATIONSHIP_GRANT_ROLE)&#x000A;  private Role role;&#x000A;&#x000A;  private Grant() {&#x000A;    this(null, null);&#x000A;  }&#x000A;&#x000A;  public Grant(IdentityType assignee, Role role) {&#x000A;      this.assignee = assignee;&#x000A;      this.role = role;&#x000A;  }&#x000A;&#x000A;  // getters and setters&#x000A;&#x000A;}</pre> <pre class="title: 'GroupMembership Relationship Type. Used to associate an User as a member of a Group.';brush: java;">&#x000A;@RelationshipStereotype(GROUP_MEMBERSHIP)&#x000A;public class GroupMembership extends AbstractAttributedType implements Relationship {&#x000A;&#x000A;  public static final RelationshipQueryParameter MEMBER = RELATIONSHIP_QUERY_ATTRIBUTE.byName("member");&#x000A;  public static final RelationshipQueryParameter GROUP = RELATIONSHIP_QUERY_ATTRIBUTE.byName("group");&#x000A;&#x000A;  private Account member;&#x000A;  private Group group;&#x000A;&#x000A;  private GroupMembership() {&#x000A;    this(null, null);&#x000A;  }&#x000A;&#x000A;  public GroupMembership(Account member, Group group) {&#x000A;    this.member = member;&#x000A;    this.group = group;&#x000A;  }&#x000A;&#x000A;  // getters and setters&#x000A;&#x000A;}</pre> <pre class="title: 'ApplicationAccess Relationship Type. Used to define that an user is allowed to access an application.';brush: java;">&#x000A;public class ApplicationAccess extends AbstractAttributedType implements Relationship {&#x000A;&#x000A;  public static final RelationshipQueryParameter ASSIGNEE = RELATIONSHIP_QUERY_ATTRIBUTE.byName("assignee");&#x000A;  public static final RelationshipQueryParameter APPLICATION = RELATIONSHIP_QUERY_ATTRIBUTE.byName("application");&#x000A;&#x000A;  @InheritsPrivileges("application")&#x000A;  private IdentityType assignee;&#x000A;&#x000A;  private Application application;&#x000A;&#x000A;  @AttributeProperty&#x000A;  private Date lastSuccessfulLogin;&#x000A;&#x000A;  @AttributeProperty&#x000A;  private Date lastFailedLogin;&#x000A;&#x000A;  @AttributeProperty&#x000A;  private int failedLoginAttempts;&#x000A;&#x000A;  private ApplicationAccess() {&#x000A;  }&#x000A;&#x000A;  public ApplicationAccess(IdentityType assignee, Application application) {&#x000A;      setAssignee(assignee);&#x000A;      setApplication(application);&#x000A;  }&#x000A;&#x000A;  // getters and setters&#x000A;&#x000A;}</pre> <p> All relationship types are implementing the <code>Relationship</code>. You may also notice the use of <code>AbstractAttributedType</code>. In PicketLink, every single type is a child of <code>AttributedType</code>. Including partitions, identity and account types. This base class is just a handy way to get a default implementation for some methods required by the <code>Relationship</code> interface. </p> <p> Some relationships are very common to most use cases and PicketLink also provides some stereotypes to represent them. This is the case for the <code>Grant</code> and <code>GroupMembership</code>. Relationships stereotypes are defined using the <code>@RelationshipStereotype</code>. For the same reason as identity types, relationship stereotypes are important to reuse some built-in features provided by PicketLink. For instance, the security annotations used to check access based on the user roles. The <code>ApplicationAccess</code> type does not have a corresponding stereotype, so we don't need to define one. It is a project-specific relationship required to satisfy our requirements. </p> <p> You may also notice the use of <code>@InheritsPrivileges</code> in <code>ApplicationAccess</code>. This is a very important configuration to check access for users considering the group they belong. The <b>assignee</b> of this relationship is a generic <code>IdentityType</code>, which means it can be an <code>User</code> or a <code>Group</code>. When the assignee is a group, all its members are also allowed to access the application. </p> <p> Relationships can declare formal attributes to define any specific state. For instance, in <code>ApplicationAccess</code> we are defining some additional properties to store the number of failed login attempts and the date of the last success and unsuccessful login of an user in an application. </p> <p> Now let's take a look how to manage those relationship types: </p> <pre class="title: 'Granting Roles to Users.';brush: java;">&#x000A;PartitionManager partitionManager = getPartitionManager();&#x000A;Realm acmeRealm = getAcmeRealm();&#x000A;IdentityManager acmeIdentityManager = partitionManager.createIdentityManager(acmeRealm);&#x000A;Role globalRole = new Role("Global Role");&#x000A;&#x000A;// stores the global role&#x000A;acmeIdentityManager.add(globalRole);&#x000A;&#x000A;// we need an identity manager instance for acme realm. so we can store the role&#x000A;Application applicationPartition = getSalesApplicationPartition();&#x000A;IdentityManager applicationIdentityManager = partitionManager.createIdentityManager(applicationPartition);&#x000A;Role applicationRole = new Role("Application Role");&#x000A;&#x000A;// stores a application specific role&#x000A;applicationIdentityManager.add(applicationRole);&#x000A;&#x000A;User user = new User("mary");&#x000A;&#x000A;// stores the user in the acme partition&#x000A;acmeIdentityManager.add(user);&#x000A;&#x000A;RelationshipManager relationshipManager = partitionManager.createRelationshipManager();&#x000A;&#x000A;// assign global role to user&#x000A;relationshipManager.add(new Grant(user, globalRole));&#x000A;&#x000A;// assign application specific role to user&#x000A;relationshipManager.add(new Grant(user, applicationRole));&#x000A;&#x000A;RelationshipQuery&lt;Grant&gt; query = relationshipManager.createRelationshipQuery(Grant.class);&#x000A;&#x000A;query.setParameter(Grant.ASSIGNEE, user);&#x000A;&#x000A;// user is assigned with two roles&#x000A;assertEquals(2, query.getResultCount());</pre> <pre class="title: 'Adding an User as Member of a Group.';brush: java;">&#x000A;// we need an identity manager instance for acme realm. so we can store the group&#x000A;PartitionManager partitionManager = getPartitionManager();&#x000A;Realm acmeRealm = getAcmeRealm();&#x000A;IdentityManager acmeIdentityManager = partitionManager.createIdentityManager(acmeRealm);&#x000A;Group globalGroup = new Group("Global Group");&#x000A;&#x000A;// stores the global group&#x000A;acmeIdentityManager.add(globalGroup);&#x000A;&#x000A;// we need an identity manager instance for acme realm. so we can store the group&#x000A;Application applicationPartition = getSalesApplicationPartition();&#x000A;IdentityManager applicationIdentityManager = partitionManager.createIdentityManager(applicationPartition);&#x000A;Group applicationGroup = new Group("Application Group");&#x000A;&#x000A;// stores a application specific group&#x000A;applicationIdentityManager.add(applicationGroup);&#x000A;&#x000A;User user = new User("mary");&#x000A;&#x000A;// stores the user in the acme partition&#x000A;acmeIdentityManager.add(user);&#x000A;&#x000A;RelationshipManager relationshipManager = partitionManager.createRelationshipManager();&#x000A;&#x000A;// user us now a member of global group&#x000A;relationshipManager.add(new GroupMembership(user, globalGroup));&#x000A;&#x000A;// user us now a member of application specific group&#x000A;relationshipManager.add(new GroupMembership(user, applicationGroup));&#x000A;&#x000A;RelationshipQuery&lt;GroupMembership&gt; query = relationshipManager.createRelationshipQuery(GroupMembership.class);&#x000A;&#x000A;query.setParameter(GroupMembership.MEMBER, user);&#x000A;&#x000A;// user is member of two groups&#x000A;assertEquals(2, query.getResultCount());</pre> <pre class="title: 'Allowing User to Access an Application.';brush: java;">&#x000A;// we need an identity manager instance for acme realm. so we can store the user&#x000A;PartitionManager partitionManager = getPartitionManager();&#x000A;Realm acmeRealm = getAcmeRealm();&#x000A;IdentityManager acmeIdentityManager = partitionManager.createIdentityManager(acmeRealm);&#x000A;&#x000A;User user = new User("mary");&#x000A;&#x000A;// stores the user in the acme partition&#x000A;acmeIdentityManager.add(user);&#x000A;&#x000A;RelationshipManager relationshipManager = partitionManager.createRelationshipManager();&#x000A;&#x000A;// grant access to application&#x000A;relationshipManager.add(new ApplicationAccess(user, getSalesApplication()));&#x000A;&#x000A;RelationshipQuery<ApplicationAccess> query = relationshipManager.createRelationshipQuery(ApplicationAccess.class);&#x000A;&#x000A;query.setParameter(ApplicationAccess.ASSIGNEE, user);&#x000A;&#x000A;// user is assigned with two roles&#x000A;assertEquals(1, query.getResultCount());</pre> <pre class="title: 'Allowing Groups to Access an Application.';brush: java;">&#x000A;// we need an identity manager instance for acme realm. so we can store the group&#x000A;PartitionManager partitionManager = getPartitionManager();&#x000A;Realm acmeRealm = getAcmeRealm();&#x000A;IdentityManager acmeIdentityManager = partitionManager.createIdentityManager(acmeRealm);&#x000A;&#x000A;Group group = new Group("Acme Administrators");&#x000A;&#x000A;// stores the group in the acme partition&#x000A;acmeIdentityManager.add(group);&#x000A;&#x000A;RelationshipManager relationshipManager = partitionManager.createRelationshipManager();&#x000A;&#x000A;// grant access to application&#x000A;Application salesApplication = getSalesApplication();&#x000A;relationshipManager.add(new ApplicationAccess(group, salesApplication));&#x000A;&#x000A;RelationshipQuery&lt;ApplicationAccess&gt; query = relationshipManager.createRelationshipQuery(ApplicationAccess.class);&#x000A;&#x000A;query.setParameter(ApplicationAccess.ASSIGNEE, group);&#x000A;&#x000A;// group is allowed to access the application&#x000A;assertEquals(1, query.getResultCount());&#x000A;&#x000A;User user = new User("mary");&#x000A;&#x000A;acmeIdentityManager.add(user);&#x000A;&#x000A;GroupMembership groupMembership = new GroupMembership(user, group);&#x000A;&#x000A;relationshipManager.add(groupMembership);&#x000A;&#x000A;// the user inherits the group privileges&#x000A;assertTrue(relationshipManager.inheritsPrivileges(user, salesApplication));&#x000A;&#x000A;relationshipManager.remove(groupMembership);&#x000A;&#x000A;// user no longer is assigned to group, thus is not allowed to access the applicaion&#x000A;assertFalse(relationshipManager.inheritsPrivileges(user, salesApplication));</pre> <p> You may notice from the examples the usage of <code>RelationshipManager</code>. This component is obtained from a <code>PartitionManager</code> and provides a set of management operations for relationships. Please take a look at the <a href="../idm_overview">Identity Management Overview</a> for more details. </p> <p> Relationships are also queryable. PicketLink provides a simple Query API for relationships. When defining your relationship types you can also specify query parameters just like we did with identity types. Considering the requirements, we are now able to query all roles, groups and applications for an user. Or even retrieve which users are allowed to access a specific application. </p> <h2>Configuring the Identity Model</h2> <p> As you might know, PicketLink IDM has a <a href="http://docs.jboss.org/picketlink/2/latest/reference/html/chap-Identity_Management_-_Configuration.html">Configuration API</a> from where you provide all the necessary configuration to your application. Please, take a look at the documentation if you're not familiar with it. </p> <p> When you provide your own custom identity model, you must specify each type in the configuration. </p> <pre class="title: 'Configuring a File Identity Store with Identity Model Types.';brush: java;">&#x000A;IdentityConfigurationBuilder builder = new IdentityConfigurationBuilder();&#x000A;&#x000A;builder&#x000A;    .named("default.config")&#x000A;        .stores()&#x000A;            .file()&#x000A;                .supportType(&#x000A;                    User.class,&#x000A;                    Role.class,&#x000A;                    Group.class,&#x000A;                    Realm.class,&#x000A;                    Application.class)&#x000A;                .supportGlobalRelationship(&#x000A;                    Grant.class,&#x000A;                    GroupMembership.class,&#x000A;                    ApplicationAccess.class)&#x000A;                .supportCredentials(true)&#x000A;                .preserveState(false)&#x000A;                .workingDirectory("/tmp/picketlink-quickstart-identity-model");</pre> <p> This is a very simple configuration if you want to start developing and testing your custom model. You don't need anything else, but a filesystem. Once you are done, you can always switch to a different identity store (eg.: JPA) and your code will still be the same. </p> <p> In the next section we'll see how to create a JPA Entity Model to map all those types from the custom identity model. </p> <h2>Mapping JPA Entities to Store the Identity Model</h2> <p> PicketLink IDM allows you to store your identity model in a database. For that, it provides a JPA Identity Store and a set of mapping annotations to be used in your JPA <code>@Entity</code> types. </p> <p> When designing your entity model, you must consider how your identity types are defined and what you need to store for each one. The decision to store them in a single table or use multiple tables is up to you. PicketLink does not force you to follow a specific design. You can even have reference to entities from an existing schema. </p> <p> Considering the custom identity model, we can use the following entities to map it. </p> <img src="http://picketlink.org/images/custom_idm_entity_model_640_480.png"/> <p> When mapping an entity to a identity model type, you need a few basic annotations: </p> <ul> <li> <code>@IdentityManager</code> - Used to specify the type being persisted by an entity. </li> <li> <code>@Identifier</code> - Used to mark a property of an entity as an identifier. In PicketLink, all types have a string valued identifier. </li> <li> <code>@AttributeValue</code> - Used to mark a property of an entity as related with a specific property of the type being mapped. If a property has different names in the entity and type, you can specify the type's property name. </li> </ul> <p> PicketLink also provides more annotations, some of them specific to the type being mapped. For instance, <code>IdentityClass</code>, <code>RelationshipClass</code> and <code>Partition</code>. Which you'll see shortly. </p> <h3> Mapping Partition Types </h3> <p> Let's start with creating the mapping for <code>Partition</code> types. According with the diagram, three entities are being used to map partitions: <code>PartitionTypeEntity</code>, <code>ApplicationRealmTypeEntity</code> and <code>RealmTypeEntity</code>. </p> <pre class="title: 'Base Entity for Partitions';brush: java;">&#x000A;@IdentityManaged(Partition.class)&#x000A;@Entity&#x000A;@Inheritance(strategy = InheritanceType.JOINED)&#x000A;public class PartitionTypeEntity {&#x000A;&#x000A;    @Identifier&#x000A;    @Id&#x000A;    private String id;&#x000A;&#x000A;    @AttributeValue&#x000A;    private String name;&#x000A;&#x000A;    @PartitionClass&#x000A;    private String typeName;&#x000A;&#x000A;    @ConfigurationName&#x000A;    private String configurationName;&#x000A;&#x000A;    // getters and setters&#x000A;}</pre> <pre class="title: 'ApplicationRealm Partition Mapping';brush: java;">&#x000A;@IdentityManaged(ApplicationRealm.class)&#x000A;@Entity&#x000A;public class ApplicationRealmTypeEntity extends PartitionTypeEntity {&#x000A;}</pre> <pre class="title: 'Realm Partition Mapping';brush: java;">&#x000A;@IdentityManaged(Realm.class)&#x000A;@Entity&#x000A;public class RealmTypeEntity extends PartitionTypeEntity {&#x000A;&#x000A;    @AttributeValue&#x000A;    private boolean enforceSSL;&#x000A;&#x000A;    @AttributeValue&#x000A;    private int numberFailedLoginAttempts;&#x000A;&#x000A;    @AttributeValue&#x000A;    @Column(columnDefinition = "TEXT")&#x000A;    private byte[] publickKey;&#x000A;&#x000A;    @AttributeValue&#x000A;    @Column(columnDefinition = "TEXT")&#x000A;    private byte[] privateKey;&#x000A;&#x000A;    // getters and setters&#x000A;}</pre> <p> Regardless the type being mapped, the <code>@IdentityManaged</code> annotation plays an important role. It tells to PicketLink which type is related with a specific JPA entity. In all cases above, we're using it to tell to PicketLink that each entity persists a specific partition type. </p> <p> For instance, if you take the <code>RealmTypeEntity</code> you'll see that <code>@IdentityManaged(Realm.class)</code> is indicating that the entity is persisting <code>Realm</code> instances. </p> <p> The <code>@AttributeValue</code> annotation provides a simple way to indicate that a specific property of a type must be stored by a property of an entity. In all cases above, you may notice that both type and entity have the same property names. And this is how PicketLink will set values from one to another when storing or retrieving instances from the underlying storage. </p> <p> Specifically considering our entity model, both <code>ApplicationRealmTypeEntity</code> and <code>RealmTypeEntity</code> are extending <code>PartitionTypeEntity</code>. You can say: "Why not map both partitions using a single entity?". Well, you can do that. PicketLink does not force your design decisions. But for this guide, this is probably the best way to showcase all features. </p> <p> Given that we have two entities representing partitions, we need to be able to create references for both when mapping other types. Remember, some of them may be stored in both <code>Realm</code> or <code>ApplicationRealm</code> partitions such as roles and groups. And that is the main motivation for the existence of the <code>PartitionTypeEntity</code> base entity. You'll understand that better once we start mapping identity types. </p> <p> For last, when mapping partitions you'll need some additional annotations. </p> <ul> <li> <code>PartitionClass</code> - Used to store the full qualified name of a partition type. PicketLink needs this to umarshall entities from the database. </li> <li> <code>ConfigurationName</code> - Used to store the configuration name used to store a specific partition. Pretty useful in multi-tenancy designs, where you may want to store instances using different identity stores. For instance, realms in database A and applications in database B. Or a separated database for each application. </li> </ul> <h3> Mapping Identity and Account Types </h3> <p> When mapping an <code>IdentityType</code> you'll need some additional annotations. </p> <ul> <li> <code>@IdentityClass</code> - Used to store the full qualified name of an identity type. PicketLink needs this to umarshall entities from the database. </li> <li> <code>@OwnerReference</code> - Used to mark, usually a @ManyToOne or @OneToOne association, as a reference to an owner or parent entity. The owner is usually another entity which maps a specific type. For identity types, it can be a reference to a partition entity or an <code>@OneToOne</code> entity. </li> </ul> <p> Let's take a look now how our entities are mapping the identity types from our identity model. </p> <pre class="title: 'Base Entity for IdentityType';brush: java;">&#x000A;@MappedSuperclass&#x000A;public abstract class AbstractIdentityTypeEntity {&#x000A;&#x000A;  @Identifier&#x000A;  @Id&#x000A;  private String id;&#x000A;&#x000A;  @IdentityClass&#x000A;  private String typeName;&#x000A;&#x000A;  @Temporal(TemporalType.TIMESTAMP)&#x000A;  @AttributeValue&#x000A;  private Date createdDate;&#x000A;&#x000A;  @Temporal(TemporalType.TIMESTAMP)&#x000A;  @AttributeValue&#x000A;  private Date expirationDate;&#x000A;&#x000A;  @AttributeValue&#x000A;  private boolean enabled;&#x000A;&#x000A;  // getters and setters&#x000A;&#x000A;}</pre> <pre class="title: 'Application IdentityType Mapping';brush: java;">&#x000A;@IdentityManaged(Application.class)&#x000A;@Entity&#x000A;public class ApplicationTypeEntity extends IdentityTypeEntity {&#x000A;&#x000A;    @AttributeValue&#x000A;    private String name;&#x000A;&#x000A;    @OwnerReference&#x000A;    @ManyToOne(fetch = FetchType.LAZY)&#x000A;    private RealmTypeEntity realm;&#x000A;&#x000A;    // getters and setters&#x000A;&#x000A;}</pre> <pre class="title: 'User Account Type Mapping';brush: java;">&#x000A;@IdentityManaged(User.class)&#x000A;@Entity&#x000A;public class UserTypeEntity extends IdentityTypeEntity {&#x000A;&#x000A;    @AttributeValue&#x000A;    private String userName;&#x000A;&#x000A;    @OwnerReference&#x000A;    @ManyToOne(fetch = FetchType.LAZY)&#x000A;    private RealmTypeEntity realm;&#x000A;&#x000A;    // getters and setters&#x000A;&#x000A;}</pre> <pre class="title: 'Role IdentityType Mapping';brush: java;">&#x000A;@IdentityManaged(Role.class)&#x000A;@Entity&#x000A;public class RoleTypeEntity extends IdentityTypeEntity {&#x000A;&#x000A;    @AttributeValue&#x000A;    private String name;&#x000A;&#x000A;    @OwnerReference&#x000A;    @ManyToOne(fetch = FetchType.LAZY)&#x000A;    private PartitionTypeEntity partition;&#x000A;&#x000A;    // getters and setters&#x000A;&#x000A;}</pre> <pre class="title: 'Group IdentityType Mapping';brush: java;">&#x000A;@IdentityManaged(Group.class)&#x000A;@Entity&#x000A;public class GroupTypeEntity extends IdentityTypeEntity {&#x000A;&#x000A;    @AttributeValue&#x000A;    private String name;&#x000A;&#x000A;    @AttributeValue&#x000A;    @ManyToOne&#x000A;    private GroupTypeEntity parent;&#x000A;&#x000A;    @OwnerReference&#x000A;    @ManyToOne (fetch = FetchType.LAZY)&#x000A;    private PartitionTypeEntity partition;&#x000A;&#x000A;  // getters and setters&#x000A;&#x000A;}</pre> <p> The <code>AbstractIdentityTypeEntity</code> is just a <code>@MappedSuperClass</code> providing some common methods for all identity type entities. As you can see, it defines a few properties, each one is related with the properties defined by the <code>IdentityType</code> interface. You may also notice the use of <code>IdentityClass</code>. You need it in order to tell to PicketLink which type should be used when unmarshalling instances from the database. </p> <p> Now you may understand better why we need the <code>PartitionTypeEntity</code>. As you can see, we're using it to create an <code>@OwnerReference</code> for the entities mapping identity types that can be stored in both <code>Realm</code> and <code>ApplicationRealm</code> partitions. This is the case for roles and groups, so their corresponding entities should also reflect this: <code>RoleTypeEntity</code> and <code>GroupTypeEntity</code> </p> <p> You may also notice that both <code>ApplicationTypeEntity</code> and <code>UserTypeEntity</code> are restricting the owner reference. In this case, both types can only be associated with <code>Realm</code> partitions, so we just use the <code>RealmTypeEntity</code> directly. </p> <p> Both <code>IdentityType</code> and <code>Account</code> types are mapped in the same way. The <code>UserTypeEntity</code> provides a similar mapping as the others entities. </p> <h3> Mapping Relationship Types </h3> <p> When mapping a <code>Relationship</code> you'll need some additional annotations. </p> <ul> <li> <code>@RelationshipClass</code> - Used to store the full qualified name of a relationship type. PicketLink needs this to umarshall entities from the database. </li> <li> <code>@RelationshipDescriptor</code> - This annotation must be used to indicate the field to store the name of the relationship role of a member. </li> <li> <code>@RelationshipMember</code> - The reference to a IdentityType mapped entity. This annotation is used to identify the property that holds a reference to the identity type that belongs to this relationship with a specific descriptor. Usually this annotation is used in conjunction with a @ManyToOne property referencing the entity used to store identity types. </li> <li> <code>@OwnerReference</code> - Used to mark, usually a @ManyToOne or @OneToOne association, as a reference to an owner or parent entity. The owner is usually another entity which maps a specific type. For relationship types, it should be a reference to an entity mapping the relationship. </li> <p> Let's take a look now how our entities are mapping the relationship types from our identity model. </p> <pre class="title: 'Base Entity for Relationship Types';brush: java;">&#x000A;@IdentityManaged(Relationship.class)&#x000A;@Entity&#x000A;@Inheritance(strategy = InheritanceType.JOINED)&#x000A;public class RelationshipTypeEntity {&#x000A;&#x000A;    @Identifier&#x000A;    @Id&#x000A;    private String id;&#x000A;&#x000A;    @RelationshipClass&#x000A;    private String typeName;&#x000A;&#x000A;  // getters and setters&#x000A;&#x000A;}</pre> <pre class="title: 'Grant Relationship Mapping';brush: java;">&#x000A;@IdentityManaged(Grant.class)&#x000A;@Entity&#x000A;public class GrantTypeEntity extends RelationshipTypeEntity {&#x000A;&#x000A;}</pre> <pre class="title: 'GroupMembership Relationship Mapping';brush: java;">&#x000A;@IdentityManaged(GroupMembership.class)&#x000A;@Entity&#x000A;public class GroupMembershipTypeEntity extends RelationshipTypeEntity {&#x000A;&#x000A;}</pre> <pre class="title: 'ApplicationAccess RelationshipMapping';brush: java;">&#x000A;@IdentityManaged(ApplicationAccess.class)&#x000A;@Entity&#x000A;public class ApplicationAccessTypeEntity extends RelationshipTypeEntity {&#x000A;&#x000A;  @AttributeValue&#x000A;  private Date lastSuccessfulLogin;&#x000A;&#x000A;  @AttributeValue&#x000A;  private Date lastFailedLogin;&#x000A;&#x000A;  @AttributeValue&#x000A;  private int failedLoginAttempts;&#x000A;&#x000A;  // getters and setters&#x000A;&#x000A;}</pre> <pre class="title: 'Entity to Map each IdentityType in a Relationship';brush: java;">&#x000A;@IdentityManaged({Relationship.class})&#x000A;@Entity&#x000A;public class RelationshipIdentityTypeEntity implements Serializable {&#x000A;&#x000A;  @Id&#x000A;  @GeneratedValue&#x000A;  private Long identifier;&#x000A;&#x000A;  @RelationshipDescriptor&#x000A;  private String descriptor;&#x000A;&#x000A;  @RelationshipMember&#x000A;  private String identityType;&#x000A;&#x000A;  @OwnerReference&#x000A;  @ManyToOne&#x000A;  private RelationshipTypeEntity owner;&#x000A;&#x000A;  // getters and setters&#x000A;&#x000A;}</pre> <p> The relationships are being mapped by the <code>GrantTypeEntity</code>, <code>GroupMembershipTypeEntity</code> and <code>ApplicationAccessypeEntity</code> entities. These entities define the the actual <code>Relationship</code> type that is stored by each one of them as you can see from the <code>@IdentityManaged</code> annotation. </p> <p> When mapping relationships you must provide at least two entities. One to store the relationship and another with a reference for each participating <code>IdentityType</code>. For instance, the <code>Grant</code> relationship is an association between an <code>User</code> and <code>Role</code>. The second entity is just about that, store references for each of these identity types. This is exactly for what the <code>RelationshipIdentityTypeEntity</code> is about. </p> <p> The <code>@RelationshipDescriptor</code> is always used in a string field, indicating the name of the property in a relationship that is related with a specific identity type. For instance, in <code>Grant</code>, we have the <code>role</code> property to indicate the role being granted. The name "role" will be stored in the descriptor field. Basically, PicketLink needs this information to know where an identity type should be setted when unmarshalling a relationship from the database. </p> <p> The <code>RelationshipMember</code> is defined to a property that can be either a simple string <code>@Column</code> field or a <code>ManyToOne</code> field with the reference to the entity mapping identity types. In our case, we need it defined as string because we're supporting a multi-partition relationship. That means, that relationships can reference types from different partitions. If you're working with a single partition, you can define the type of the field as a direct reference to an identity type mapping. If you want an example, here is one from the <a href="https://github.com/picketlink/picketlink/blob/master/modules/idm/simple-schema/src/main/java/org/picketlink/idm/jpa/model/sample/simple/RelationshipIdentityTypeEntity.java">Basic Model</a> provided by PicketLink. One more reason why we need a custom identity model and not the Basic Model. </p> <p> You can even provide multiple <code>RelationshipIdentityTypeEntity</code> to each relationship type if you want to store the participants into separate tables. Just create an entity like this one where the <code>@OwnerReference</code> is a reference to a specific relationship entity, for example <code>GrantTypeEntity</code>. In this case, you must also specify the <code>Grant</code> relationship in the <code>@IdentityManaged</code> annotation. </p> <p> The <code>@OwnerReference</code> must also be annotated to entities mapping the participants in a relationship. It is just a reference to the entity mapping the relationship itself. In this case, we're defining a reference to the <code>RelationshipTypeEntity</code> which is the base entity for all relationship entities. </p> <h3> Mapping Credentials or CredentialStorage Types </h3> <p> In PicketLink credentials are stored by a specific <code>CredentialStorage</code>. Please, take a look at the <a href="http://docs.jboss.org/picketlink/2/latest/reference/html-single/#The_CredentialStorage_interface">documentation</a> for more details. </p> <p> PicketLink also provides a built-in credential storage for password-based credentials, the <code>EncodedPasswordStorage</code>. Given that, we need to create a credential stoge every time we need password authentication, we just need to provide an entity that knows how to store the build-in storage. </p> <pre class="title: 'Entity to Map each IdentityType in a Relationship';brush: java;">&#x000A;public class EncodedPasswordStorage implements CredentialStorage {&#x000A;&#x000A;  private Date effectiveDate;&#x000A;  private Date expiryDate;&#x000A;  private String encodedHash;&#x000A;  private String salt;&#x000A;&#x000A;  // getters and setters&#x000A;&#x000A;}</pre> <p> Just like we did so far, we need now to provide an entity that knows how to store each of these properties. When mapping a <code>CredentialStorage</code> you'll need some additional annotations. </p> <ul> <li> <code>@ManagedCredential</code> - This annotation is applied to an entity class to indicate that it contains managed credential-related state. Basically, it defines which credential storage class is managed by declaring entity. </li> <li> <code>@OwnerReference</code> - The owner of the credential. The field annotated with this annotation must be a reference to another entity wich is mapping an <code>Account</code> type. </li> <li> <code>@CredentialClass</code> - Used to store the full qualified name of a credential storage. PicketLink needs this to umarshall entities from the database. </li> <li> <code>@CredentialProperty</code> - Specifies that a property should be mapped to a specific field of a <code>CredentialStorage</code>. It behaves just like <code>AttributeValue</code>. </li> <li> <code>@EffectiveDate</code> - Used to mark a <code>Date</code> with the <code>CredentialStorage.effectiveDate</code> property. </li> <li> <code>@ExpiryDate</code> - Used to mark a <code>Date</code> with the <code>CredentialStorage.expiryDate</code> property. </li> </ul> <pre class="title: 'Entity to Map each IdentityType in a Relationship';brush: java;">&#x000A;@ManagedCredential(EncodedPasswordStorage.class)&#x000A;@Entity&#x000A;public class PasswordCredentialTypeEntity {&#x000A;&#x000A;  @Id&#x000A;  @GeneratedValue&#x000A;  private Long id;&#x000A;&#x000A;  @OwnerReference&#x000A;  @ManyToOne&#x000A;  private UserTypeEntity owner;&#x000A;&#x000A;  @CredentialClass&#x000A;  private String typeName;&#x000A;&#x000A;  @Temporal(TemporalType.TIMESTAMP)&#x000A;  @EffectiveDate&#x000A;  private Date effectiveDate;&#x000A;&#x000A;  @Temporal(TemporalType.TIMESTAMP)&#x000A;  @ExpiryDate&#x000A;  private Date expiryDate;&#x000A;&#x000A;  @CredentialProperty(name = "encodedHash")&#x000A;  private String passwordEncodedHash;&#x000A;&#x000A;  @CredentialProperty(name = "salt")&#x000A;  private String passwordSalt;&#x000A;&#x000A;  // getters and setters&#x000A;&#x000A;}</pre> <h2> Configuring the JPA Identity Store </h2> <p> To start using this model we need to configure the JPA Identity Store accordingly as follows: </p> <pre class="title: 'Entity to Map each IdentityType in a Relationship';brush: java;">&#x000A;builder&#x000A;  .named("default.config")&#x000A;      .stores()&#x000A;          .jpa()&#x000A;              // defines each identity type&#x000A;              .supportType(&#x000A;                  User.class,&#x000A;                  Role.class,&#x000A;                  Group.class,&#x000A;                  Realm.class,&#x000A;                  Application.class,&#x000A;                  ApplicationRealm.class)&#x000A;              // defines each relationship type&#x000A;              .supportGlobalRelationship(&#x000A;                  Grant.class,&#x000A;                  GroupMembership.class,&#x000A;                  ApplicationAccess.class)&#x000A;              // we need to support credentials&#x000A;              .supportCredentials(true)&#x000A;              // defines the entities&#x000A;              .mappedEntity(&#x000A;                  ApplicationAccessTypeEntity.class,&#x000A;                  ApplicationTypeEntity.class,&#x000A;                  ApplicationRealmTypeEntity.class,&#x000A;                  PartitionTypeEntity.class,&#x000A;                  GrantTypeEntity.class,&#x000A;                  GroupMembershipTypeEntity.class,&#x000A;                  GroupTypeEntity.class,&#x000A;                  RealmTypeEntity.class,&#x000A;                  RoleTypeEntity.class,&#x000A;                  UserTypeEntity.class,&#x000A;                  PasswordCredentialTypeEntity.class,&#x000A;                  RelationshipTypeEntity.class,&#x000A;                  RelationshipIdentityTypeEntity.class);</pre> <p> For more information, please check the <a href="http://docs.jboss.org/picketlink/2/latest/reference/html-single/#chap-Identity_Management_-_Working_with_JPA">documentation.</a> </p> <h3>Summary</h3> <p> Hopefully this guide helped you to understand some core concepts of PicketLink regarding how to extend it and provide your own identity model. </p> <p> We covered some important and basic concepts that will help you to deep dive into some more advanced concepts of PicketLink and create more advanced and complex usecases. </p> <p> Most of the things we covered in this guide are also demonstrated by the quickstarts, from where you can get much more usage examples considering different usecases. </p> <p> Fell free to contribute with your own guides and help us to improve PicketLink ! Enjoy it ! </p> </ul> </div> </div> </div> </div> </div> <footer class="container"> <div class="row-fluid"> <div class="span2 offset1"> <h4>Navigate</h4> <ul> <li> <a href="http://picketlink.org/about/" title="About">About</a> </li> <li> <a href="http://picketlink.org/gethelp/" title="Get Help">Get Help</a> </li> <li> <a href="https://community.jboss.org/en/picketlink?view=discussion" title="Forums">Forums</a> </li> <li> <a href="http://picketlink.org/gettingstarted/" title="Download">Download</a> </li> </ul> </div> <div class="span2"> <h4>Follow Us</h4> <ul> <li> <a href="https://twitter.com/picketlink" title="Twitter">Twitter</a> </li> <li> <a href="https://plus.google.com/s/Picketlink" title="Google+">Google+</a> </li> </ul> </div> <div class="span2"> <h4>Contribute</h4> <ul> <li> <a href="https://issues.jboss.org/browse/PLINK" title="Submit a bug">Submit a bug</a> </li> <li> <a href="https://github.com/picketlink/picketlink/fork" title="Fork">Fork The Code</a> </li> <li> <a href="http://picketlink.org/joinus/" title="Join Us">Join Us</a> </li> </ul> </div> <div class="span3 offset1"> <h4>Apache 2.0 License</h4> <p>All dependencies of this project are available under the ASLv2 or a compatible license.</p> </div> </div> <div class="row-fluid"> <div class="span6 offset1"> <p style="margin-top: 5px; font-size: 80%;"> © Copyright 2013 Red Hat, Inc. <br/> <i class="icon-fire"></i> Made with <a href="https://github.com/jbossorg/bootstrap-community" style="text-decoration: underline;">JBoss Community Bootstrap</a> and <a href="http://awestruct.org/" style="text-decoration: underline;">Awestruct</a> <br/> <i class="icon-globe"></i> This website is open source! If you want to improve it, <a href="https://github.com/picketlink/web-picketlink.org" style="text-decoration: underline;">fork the project,</a> and send a pull request. <br/> <i class="icon-share"></i> Website released under <a href="http://creativecommons.org/licenses/by/3.0/" style="text-decoration: underline;">CC BY 3.0.</a> </p> </div> <div class="span3 offset1"> <div class="jbossbadge"> <a href="http://www.jboss.org/"> <img src="http://static.jboss.org/theme/images/common/jbossbadge.png"/> </a> </div> </div> </div> </footer> <div class="container" id="companyfooter"> <div class="redhatlogo"> <div id="logospacer"></div> <a href="http://www.redhat.com/"><img src="http://static.jboss.org/theme/images/common/redhat_logo.png"/></a> </div> </div> <span class="backToTop"> <a href="#top">back to top</a> </span> <script src="http://picketlink.org/css/bootstrap-community.min.js"></script> <script type='text/javascript' language='JavaScript' src='http://www.redhat.com/j/elqNow/elqCfg.js'></script> <script type='text/javascript' language='JavaScript' src='http://www.redhat.com/j/elqNow/elqImg.js'></script> <div id="oTags"> <script type="text/javascript" src="//www.redhat.com/j/s_code.js"></script> <script type="text/javascript"><!--
      var coreUrl = encodeURI(document.URL.split("?")[0]).replace(/-/g," ");
      var urlSplit = coreUrl.toLowerCase().split(/\//);
      var urlLast = urlSplit[urlSplit.length-1];
      var pageNameString = "";
      var siteName = "";
      var minorSectionIndex = 3
      if (urlLast == "") {
          urlSplit.splice(-1,1);
      }
      if (urlLast.search(/\./) >= 0) {
          if (urlLast == "index.html") {
              urlSplit.splice(-1,1);
          }
          else {
              urlSplit[urlSplit.length-1] = urlLast.split(".").splice(0,1);
          }
      }
      siteName = urlSplit[2].split(".")[1];
      s.prop14 = s.eVar27 = siteName || "";
      s.prop15 = s.eVar28 = urlSplit[minorSectionIndex] || "";
      s.prop16 = s.eVar29 = urlSplit[minorSectionIndex+1] || "";
      pageNameString = urlSplit.splice(3).join(" | ");
      s.pageName = "jboss | community | " + siteName + " | " + pageNameString;
      s.server = "jboss";
      s.channel = "jboss | community";
      s.prop4 = s.eVar23 = encodeURI(document.URL);
      s.prop21 = s.eVar18 = coreUrl;
      s.prop2 = s.eVar22 = "en";
      s.prop3 = s.eVar19 = "us";
      //--></script> <script type="text/javascript" src="//www.redhat.com/j/rh_omni_footer.js"></script> <script language="JavaScript" type="text/javascript"><!--
      if(navigator.appVersion.indexOf('MSIE')>=0)document.write(unescape('%3C')+'\!-'+'-')
      //--></script> <noscript><a href="http://www.omniture.com" title="Web Analytics"><img src="https://smtrcs.redhat.com/b/ss/redhatcom,redhatglobal/1/H.25.4--NS/0?[AQB]&cdp=3&[AQE]" height="1" width="1" border="0" alt=""/></a></noscript> </div> <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script> <script type="text/javascript">
    try {
    var pageTracker = _gat._getTracker("UA-46906810-1");
    pageTracker._trackPageview();
    } catch(err) {}</script> </body> </html>